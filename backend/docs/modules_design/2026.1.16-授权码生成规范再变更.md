# 授权码生成规范再变更（2026-01-16）
## 1. 背景与目标
授权码（Authorization Code）当前用于“在线激活”：客户端携带授权码请求服务端，服务端签发许可证文件。

当客户环境无网络时，在线激活不可用，因此需要一段可由客户端内置 RSA 公钥解析/验签的字符串，携带授权的配置（到期时间、功能配置、使用限制等），客户端在离线场景可据此完成自校验与功能开关。

本次“再变更”的核心原则：
- 不改动现有授权码本体格式与核心激活流程
- 仅在“复制/导出”时提供“产品激活码（Product Activation Code）”扩展串

## 2. 当前代码实现（现状梳理）
### 2.1 授权码基础格式（旧规则，核心流程依赖）
当前核心流程依赖的授权码格式为 4 段：

```
LIC-{客户ID前4位}-{12位随机}-{4位校验码}
```

示例：`LIC-F44D-GvBzMfEGbxMP-LVAA`

对应实现：
- 生成：`backend/pkg/utils/authorization_code.go` 的 `GenerateLegacyAuthorizationCode()`（由 `backend/internal/service/authorization_code_service.go` 的 `generateAuthorizationCode()` 调用）
- 使用：核心流程以数据库匹配为准（`licenseRepo.GetAuthorizationCodeByCode`），不做额外格式校验

### 2.2 历史“自包含授权码”方案（已移除）
历史上曾存在一套“自包含授权码”的生成/解析方案（已删除，不再使用）：
- 曾实现：`backend/pkg/utils/license_codec.go`（已删除，原 `EncodeLicenseData()/DecodeLicenseData()`）
- 格式：`LIC-{2位随机}-{Base64数据}`（3 段示例：`LIC-B5-xxxx...`）
- 特征：将到期时间/配置等编码进 `{Base64数据}`，并做签名校验

该格式与 2.1 的旧规则（4 段）以及现有激活流程不一致，已按本次“再变更”回退/统一到 2.1。

受影响的核心流程（已改回旧规则生成）：
- `POST /api/v1/authorization-codes`（管理端创建授权码）
- `POST /api/cu/orders`（C 端下单创建授权码）

### 2.3 授权码下载包（保持不变）
现有下载接口会导出一个 zip，包含：
- `authorization_code.txt`：仅包含授权码字符串（`authCode.Code`）
- `rsa_public_key.pem`：RSA 公钥（从配置 `cfg.License.RSA.PublicKeyPath` 读取）

对应实现：
- 路由：`GET /api/v1/authorization-codes/:id/download`
- Service：`backend/internal/service/authorization_code_service.go` 的 `GenerateAuthorizationFile()`
- Handler：`backend/internal/api/handlers/authorization_code_handler.go` 的 `DownloadAuthorizationFile()`

### 2.4 “公钥可解析”的签名封装（可复用）
代码中已存在一套「RSA 私钥签名 + Base64 封装」实现，客户端可用公钥验签后得到原始 JSON：
- 服务端签名封装：`backend/internal/service/license_service.go` 的 `signLicenseFile()`
- 签名算法：`RSA-PSS-SHA256`（`backend/pkg/utils/crypto.go` 的 `RSAPrivateKey.SignData()` / `RSAPublicKey.VerifySignature()`）
- 客户端验签示例：`backend/cmd/client-demo/main.go` 的 `decryptLicenseFile()`

说明：这里的“加密字符串”在现有体系中更贴近“签名封装字符串”（提供防篡改与来源可信验证，不提供保密性）。

## 3. 本次再变更：产品激活码（Product Activation Code）
### 3.1 输出格式
在需要离线激活/离线解析配置的场景，对外展示/复制的字符串为“产品激活码”：

```
{授权码}&{配置签名封装串}
```

示例：`LIC-F44D-GvBzMfEGbxMP-LVAA&{payload}`

其中：
- `{授权码}`：保持现有 4 段格式不变（用于在线激活、数据库查找、订单绑定等核心流程）
- `{payload}`：可由客户端内置 RSA 公钥验签并解析出 JSON 的字符串

### 3.2 payload（配置签名封装串）业务 JSON
payload 解析后的业务 JSON（即“配置 JSON”）建议至少包含：

```json
{
  "authorization_code": "LIC-F44D-GvBzMfEGbxMP-LVAA",
  "start_date": "2026-01-16T00:00:00+08:00",
  "end_date": "2026-12-31T23:59:59+08:00",
  "deployment_type": "standalone",
  "max_activations": 100,
  "feature_config": {},
  "usage_limits": {},
  "custom_parameters": {},
  "generated_at": "2026-01-16T12:00:00+08:00",
  "ver": 1
}
```

字段来源：
- `authorization_code/start_date/end_date/deployment_type/max_activations/feature_config/usage_limits/custom_parameters`：来自 `authorization_codes` 表记录
- `generated_at`：服务端生成时间

### 3.3 payload 生成规则（服务端）
复用许可证文件的签名封装方式（`license_service.signLicenseFile()` 的数据结构与算法）：

1. 构造“配置 JSON”（见 3.2），序列化为 `data`（JSON 字符串）
2. 使用 RSA 私钥对 `data` 进行 PSS+SHA256 签名得到 `signature`（Base64）
3. 组装签名封装对象：

```json
{
  "data": "{...配置JSON字符串...}",
  "signature": "{base64_signature}",
  "algorithm": "RSA-PSS-SHA256"
}
```

4. 将封装对象再序列化为 JSON，并 Base64 编码得到 `{payload}`

说明：
- 私钥路径来自 `cfg.License.RSA.PrivateKeyPath`
- 公钥路径来自 `cfg.License.RSA.PublicKeyPath`（客户端内置同一对公钥）
- Base64 编码沿用 `base64.StdEncoding`（与现有 license file 一致）

### 3.4 客户端解析规则（产品端）
1. 读取输入字符串，按 `&` 分割：
   - 只有 1 段：视为仅“在线激活授权码”
   - 至少 2 段：`base_code` 与 `payload`（取第 1 段为授权码本体）
2. 对 `payload` Base64 解码得到封装 JSON
3. 解析封装 JSON，校验 `algorithm == "RSA-PSS-SHA256"`
4. 用内置 RSA 公钥对 `data` 与 `signature` 验签
5. 验签通过后解析 `data` 得到配置 JSON，并自行校验：
   - 到期时间、功能配置、使用限制等

补充（在线激活）：
- `/api/v1/activate` 的 `authorization_code` 参数只使用 `{授权码}` 本体，不依赖 `{payload}`
- 客户端若传入完整 `product_activation_code`（`{授权码}&{payload}`），服务端会自动截取 `&` 前的 `{授权码}` 完成激活

## 4. 接口变更清单（需求说明）
### 4.1 现有接口需要调整的内容
#### 4.1.1 管理端：创建授权码
- 接口：`POST /api/v1/authorization-codes`
- 变更点：
  - `code` 生成规则统一为 2.1 的 4 段旧规则：`LIC-{客户ID前4位}-{12位随机}-{4位校验码}`
  - `feature_config/usage_limits/custom_parameters/start_date/end_date/...` 等仍按现有结构字段写入数据库（供 license file 与 payload 复用）
- 返回：响应中的 `code` 仅返回“旧规则授权码本体”（不包含 `&payload`）

#### 4.1.2 C 端：下单创建授权码
- 接口：`POST /api/cu/orders`
- 变更点：
  - 订单关联的授权码字符串（`order.authorization_code`）生成规则统一为 2.1 的旧规则
  - 同步把订单对应配置写入 `authorization_codes` 表的结构化字段（不再依赖“授权码本体自包含”）
- 返回：仍返回 `authorization_code`（旧规则授权码本体，不包含 `&payload`）
- 备注：`POST /api/cu/authorization-codes/:codeId/share` 仍可沿用旧规则生成（如后续需要统一，可复用同一生成器）

#### 4.1.3 客户端：激活
- 接口：`POST /api/v1/activate`
- 变更点：
  - 激活不需要配置 payload；仅以 `{授权码}` 做数据库匹配，不做额外格式校验
  - 兼容传入完整 `product_activation_code`：服务端自动截取 `&` 前的 `{授权码}`

### 4.2 新增接口（仅客户端使用）：获取产品激活码
为客户端提供一个“获取产品激活码”的接口，返回 `{授权码}&{payload}`。管理端不提供该接口（当前仅 C 端“复制/导出”场景需要）。

#### 4.2.1 建议接口形态（C 端）

```
POST /api/cu/authorization-codes/product-activation-code
```

请求：

```json
{
  "authorization_code": "LIC-F44D-GvBzMfEGbxMP-LVAA"
}
```

返回：

```json
{
  "code": "000000",
  "message": "success",
  "data": {
    "product_activation_code": "LIC-F44D-GvBzMfEGbxMP-LVAA&{payload}"
  }
}
```

约束与校验（建议）：
- 授权码存在，且归属当前登录客户（CustomerAuth）
- 授权码未锁定，且在有效期内

## 5. 兼容性与验收标准
### 5.1 兼容性
- 原授权码本体格式不变，在线激活核心流程不受影响
- 旧授权码仍可用；仅新增“产品激活码”扩展串用于离线解析

### 5.2 验收标准
- `product_activation_code` 中的 `{payload}` 能被客户端仅凭公钥验签并解析出配置 JSON
- 客户端可在离线场景下依据配置 JSON 完成自校验与功能开关
- 不影响 `/api/v1/activate`、授权码管理、订单等核心流程
